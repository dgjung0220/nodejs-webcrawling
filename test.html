<!DOCTYPE html>
<html lang="ko-KR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>bearpot | 곰탕</title>
<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="pingback" href="http://bearpot.net/blog/xmlrpc.php" />

<meta name="google-site-verification" content="dSzx4OHWDmBkA3iwW4hNKdmf-uNtcRNRV7Qxa0aobOg"/>
<meta name="naver-site-verification" content="ca81aba34a9a56533d015c8bcaddbaa44c3f046f"/>
<link rel='dns-prefetch' href='//s.w.org' />
<link rel="alternate" type="application/rss+xml" title="bearpot &raquo; 피드" href="http://bearpot.net/blog/feed/" />
<link rel="alternate" type="application/rss+xml" title="bearpot &raquo; 댓글 피드" href="http://bearpot.net/blog/comments/feed/" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/bearpot.net\/blog\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.8"}};
			!function(a,b,c){function d(a){var b,c,d,e,f=String.fromCharCode;if(!k||!k.fillText)return!1;switch(k.clearRect(0,0,j.width,j.height),k.textBaseline="top",k.font="600 32px Arial",a){case"flag":return k.fillText(f(55356,56826,55356,56819),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,56826,8203,55356,56819),0,0),c=j.toDataURL(),b===c&&(k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447),0,0),c=j.toDataURL(),b!==c);case"emoji4":return k.fillText(f(55358,56794,8205,9794,65039),0,0),d=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55358,56794,8203,9794,65039),0,0),e=j.toDataURL(),d!==e}return!1}function e(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i,j=b.createElement("canvas"),k=j.getContext&&j.getContext("2d");for(i=Array("flag","emoji4"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='syntax-style-css'  href='http://bearpot.net/blog/wp-content/themes/syntax/style.css?ver=4.8' type='text/css' media='all' />
<script type='text/javascript' src='http://bearpot.net/blog/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='http://bearpot.net/blog/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='http://bearpot.net/blog/wp-json/' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://bearpot.net/blog/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://bearpot.net/blog/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.8" />
		<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
		</head>

<body class="home blog">
<div id="page" class="hfeed site">
		<header id="masthead" class="site-header" role="banner">
				<div class="site-header-wrapper clear">
			<div class="site-branding">
				<h1 class="site-title"><a href="http://bearpot.net/blog/" title="bearpot" rel="home">bearpot</a></h1>
				<h2 class="site-description">곰탕</h2>
			</div>
					</div>
	</header><!-- #masthead -->
	<div id="main" class="site-main">
		<h1 id="toggle-nav" class="menu-toggle"><span class="screen-reader-text">메뉴</span></h1>
		<nav id="site-navigation" class="navigation-main" role="navigation">
			<div class="screen-reader-text skip-link"><a href="#content" title="컨텐츠로 건너뛰기">컨텐츠로 건너뛰기</a></div>
			<div class="menu-%ec%83%81%eb%8b%a8-%eb%a9%94%eb%89%b4-container"><ul id="menu-%ec%83%81%eb%8b%a8-%eb%a9%94%eb%89%b4" class="menu"><li id="menu-item-270" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-270"><a href="http://bearpot.net/blog/intro/">Intro</a></li>
<li id="menu-item-247" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-247"><a href="http://bearpot.net/blog/category/blog/">Blog</a>
<ul  class="sub-menu">
	<li id="menu-item-122" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-122"><a href="http://bearpot.net/blog/category/project/">Project</a></li>
	<li id="menu-item-172" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-172"><a href="http://bearpot.net/blog/category/nodejsmongodb/">nodejs&#038;mongodb</a>
	<ul  class="sub-menu">
		<li id="menu-item-197" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-197"><a href="http://bearpot.net/blog/category/imgoverflow-io/">imgOverflow.io</a></li>
	</ul>
</li>
	<li id="menu-item-161" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-161"><a href="http://bearpot.net/blog/category/kernel/">Kernel</a></li>
	<li id="menu-item-104" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-104"><a href="http://bearpot.net/blog/category/tensorflow/">Tensorflow</a></li>
	<li id="menu-item-115" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-115"><a href="http://bearpot.net/blog/category/webvr/">VR</a></li>
	<li id="menu-item-114" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-114"><a href="http://bearpot.net/blog/category/js/">JS</a></li>
	<li id="menu-item-105" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-105"><a href="http://bearpot.net/blog/category/uncategorized/">미분류</a></li>
</ul>
</li>
</ul></div>		</nav><!-- #site-navigation -->

	<div id="primary" class="content-area">
		<div id="content" class="site-content" role="main">

		
						
				<article id="post-273" class="no-thumbnail post-273 post type-post status-publish format-standard hentry category-blog category-project">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/07/cpu-usage-cgroup-cpusets-viewer2/" rel="bookmark">CPU Usage &#038; CGROUP CPUSETS Viewer(2)</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p style="text-align: center;">Github : <a href="https://github.com/dgjung0220/adb_viewer">https://github.com/dgjung0220/adb_viewer</a></p>
<p><span style="font-size: 10pt;">지난 시간에 이해 추가적으로 현재 Google Daydream ready device인 Google Pixel(이하 &#8216;픽셀&#8217;) 의 CPUSET Configuration 상태를 살펴보겠다.</span></p>
<pre class="nums:false lang:default decode:true">sailfish:/dev/cpuset $ ls
background            cpu_exclusive  mem_exclusive           memory_spread_page sched_load_balance
camera-daemon         cpus           mem_hardwall            memory_spread_slab sched_relax_domain_level
cgroup.clone_children effective_cpus memory_migrate          mems               system-background
cgroup.procs          effective_mems memory_pressure         notify_on_release  tasks
cgroup.sane_behavior  foreground     memory_pressure_enabled release_agent      top-app</pre>
<p><span style="font-size: 10pt;">픽셀의 cpuset fs 마운트 위치는 /dev/cpuset 이다. 이 것은 항상 동일한 것은 아니다. 보통 init.rc 에 부팅시에 마운트될 수 있도록 기술하는데 루팅이 완료된 디바이스라면 루트에서 cat init.rc | grep cpuset 이라고 쳐보면 어떻게 마운트되고 있는지 확인할 수 있을 것이다.</span></p>
<pre class="nums:false lang:default decode:true ">sailfish:/ $ cat /dev/cpuset/cpus
0-3
sailfish:/ $ cat /dev/cpuset/foreground/cpus
0-2
sailfish:/ $ cat /dev/cpuset/background/cpus
0
sailfish:/ $ cat /dev/cpuset/system-background/cpus
0-2
sailfish:/ $ cat /dev/cpuset/top-app/cpus
0-3</pre>
<p><span style="font-size: 10pt;">픽셀은 0-3 총 4개의 Core 수를 가진 디바이스이고 각 foreground, background, system-background 는 위와 같이 설정되어 있다. 각 그룹 아래의 노드들도 중요한데 아래의 커맨드 출력 결과를 통해 어떤 노드들이 있는지 살펴보길 바란다.</span></p>
<pre class="nums:false lang:default decode:true">sailfish:/dev/cpuset/foreground $ ls
boost                 cpu_exclusive  effective_mems memory_migrate     memory_spread_slab sched_load_balance
cgroup.clone_children cpus           mem_exclusive  memory_pressure    mems               sched_relax_domain_level
cgroup.procs          effective_cpus mem_hardwall   memory_spread_page notify_on_release  tasks</pre>
<p><span style="font-size: 10pt;">그리고 CPUSET Enable 상태에서는 각 그룹에 테스크가 할당되어 돌아간다. 아래의 커맨트를 통해 어떤 테스크가 할당되어 있는지 확인하도록 한다.</span></p>
<pre class="nums:false lang:default decode:true ">sailfish:/ $ cat /dev/cpuset/foreground/tasks
251
328
498
542
543
..</pre>
<p>&nbsp;</p>
<p>1. package.json</p>
<pre class="lang:default decode:true ">"dependencies": {
    "adbkit": "^2.10.0",
    "bluebird": "^3.5.0",
    "collections": "^5.0.6",
    "electron-pug": "^1.5.1"
  },
  "devDependencies": {
    "asar": "^0.13.0",
    "electron": "^1.6.11",
    "electron-installer-squirrel-windows": "^1.3.0",
    "electron-packager": "^8.7.2"
  }</pre>
<p><span style="font-size: 10pt;">pakage.json은 위와 같이 구성되었다. 각 모듈들을 간략히 살펴보면 아래와 같다.</span></p>
<p><span style="font-size: 12pt;">dependencies</span></p>
<ul style="list-style-type: square;">
<li><span style="font-size: 10pt;"><a href="https://github.com/openstf/adbkit">adbkit </a>: Node.js client for Android Debug Bridge server.</span></li>
<li><span style="font-size: 10pt;"><a href="https://www.npmjs.com/package/bluebird">bluebird </a>: Promise 문법을 위한 좋은 친구</span></li>
<li><span style="font-size: 10pt;">collections : JS 용 collections 구현 모듈</span></li>
<li><span style="font-size: 10pt;">electron-pug : electron 용 pug 모듈</span></li>
</ul>
<p><span style="font-size: 12pt;">devDependencies</span></p>
<ul style="list-style-type: square;">
<li><span style="font-size: 10pt;">asar : asar 압축 지원 모듈</span></li>
<li><span style="font-size: 10pt;">electron</span></li>
<li><span style="font-size: 10pt;">electron-packager : electron 패키징 모듈</span></li>
<li><span style="font-size: 10pt;">electron-installer-squirrel-windows : 윈도우용 일렉트론 인스톨러 빌드 모듈</span></li>
</ul>
<p>2. Electron Packaging</p>
<pre class="lang:default decode:true ">"scripts": {    
    "start": "electron .",
    "poststart" : "electron-packager . cpuViewer --asar --platform win32 --arch x64 --out dist/"
}</pre>
<p><span style="font-size: 10pt;">Electron Packaging 모듈을 이용하여 일렉트론을 패키징한다. 위의 스크립트를 사용하면, npm start 이후에 패키징이 시작된다. 개별적으로 커맨드를 수행할수도 있다. 위의 커맨드가 수행되면, /dist 폴더가 생성되며 dist/CpuViewer-win32-x64 폴더 하위로 프로젝트가 패키징되는 것을 확인할 수 있다. 이 때 &#8211;asar 옵션은 Asar 압축 명령 옵션이다. Asar 은 일렉트론에서 지원하는 압축포맷인데, asar 압축 없이 패키징을 수행하게 되면 resources 폴더의 app 폴더에 모든 소스가 그대로 존재하는 것을 확인할 수 있다. 이 폴더를 asar 옵션을 통해 app.asar 로 변환해준다. 물론 개별적으로 압축 명령 수행 가능하다.</span></p>
<pre class="lang:default decode:true ">asar p ./dist/CpuViewer-win32-x64/resources/app.asar ./dist/CpuViewer-win32-x64/resources/app
</pre>
<p>&nbsp;</p>
<p>3. Installer build</p>
<p><span style="font-size: 10pt;">electron-installer-squirrel-windows 모듈을 통해 패키지를 인스톨러로 빌드한다. electron 빌드에는 electron-winstaller 등 다양한 모듈이 존재하니 한 번쯤 비교해보는 것도 좋다. 명령어로도 가능하지만 아래와 같이 installer.js 를 만들어 사용한다.</span></p>
<pre class="lang:default decode:true">// installer.js
var createInstaller = require('electron-installer-squirrel-windows');

createInstaller({
    name : 'cpuViewer',
    path: './dist/cpuViewer-win32-x64',
    out: './dist/installer',
    authors: 'Donggoo Jung',
    exe: 'cpuViewer.exe',
    appDirectory: './dist/cpuViewer-win32-x64',
    overwrite: true,
    setup_icon: 'favicon.ico'
}, function done (e) {
    console.log('Build Complete');
});</pre>
<p>&nbsp;</p>
<p>4. 구현</p>
<p><img class="size-full wp-image-285 aligncenter" src="http://bearpot.net/blog/wp-content/uploads/2017/08/1.png" alt="" width="928" height="513" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/1.png 928w, http://bearpot.net/blog/wp-content/uploads/2017/08/1-300x166.png 300w, http://bearpot.net/blog/wp-content/uploads/2017/08/1-768x425.png 768w" sizes="(max-width: 928px) 100vw, 928px" /></p>
<p><span style="font-size: 10pt;">전체적인 화면은 위와 같이 구성했다.</span></p>
<ul>
<li><span style="font-size: 10pt;">① Show tracking device : adb connect 시 device name 이 보여지도록 하였다.</span></li>
<li><span style="font-size: 10pt;">② Set refresh rate : 전체적인 결과물의 리프레시 레이트를 조정.</span></li>
<li><span style="font-size: 10pt;">③ Show CPU Usage : 전체 CPU 및 유저, 시스템 CPU Usage, 그리고 각 코어별로 보여주도록 구성했다.</span></li>
<li><span style="font-size: 10pt;">④ Show CPUSET Status : /dev/cpusets 의 코어 할당 상태.</span></li>
<li><span style="font-size: 10pt;">⑤ Show running process by cpusets : /dev/cpusets/tasks </span></li>
</ul>
<p><span style="font-size: 10pt;">정상적으로 동작하면 아래와 같이 표시된다. (Google Pixel)</span></p>
<p><img class="alignnone size-full wp-image-282" src="http://bearpot.net/blog/wp-content/uploads/2017/08/5.jpg" alt="" width="1200" height="1018" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/5.jpg 1200w, http://bearpot.net/blog/wp-content/uploads/2017/08/5-300x255.jpg 300w, http://bearpot.net/blog/wp-content/uploads/2017/08/5-768x652.jpg 768w, http://bearpot.net/blog/wp-content/uploads/2017/08/5-1024x869.jpg 1024w, http://bearpot.net/blog/wp-content/uploads/2017/08/5-1008x855.jpg 1008w" sizes="(max-width: 1200px) 100vw, 1200px" /></p>
<p><span style="font-size: 10pt;">하지만 VR 앱을 실행하면 아래와 같은 상태로 동작하는 것을 확인할 수 있다.</span></p>
<p><img class="alignnone size-full wp-image-283" src="http://bearpot.net/blog/wp-content/uploads/2017/08/6.jpg" alt="" width="1176" height="905" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/6.jpg 1176w, http://bearpot.net/blog/wp-content/uploads/2017/08/6-300x231.jpg 300w, http://bearpot.net/blog/wp-content/uploads/2017/08/6-768x591.jpg 768w, http://bearpot.net/blog/wp-content/uploads/2017/08/6-1024x788.jpg 1024w, http://bearpot.net/blog/wp-content/uploads/2017/08/6-1008x776.jpg 1008w" sizes="(max-width: 1176px) 100vw, 1176px" /></p>
<p><span style="font-size: 10pt;">CPU Usage 가 크게 올라갔으며, 지속적으로 frequency 가 1209600 으로 유지되는 것을 확인할 수 있다. 그리고 VR 프로세스들이 top-app 에 할당되어 돌아가고 있다. 데이드림에는 CPU 성능 유지를 위해 min clock 을 1209600 으로 유지하는 코드가 포함되어 있다. 그래서 VR 앱을 켜고 뷰어를 계속 확인면 절대 1209600 이하로 떨어지지 않는 것을 확인할 수 있다.</span></p>
<p>5. 마무리</p>
<p><span style="font-size: 10pt;">계속 회사에 마무리되지 않은 일들이 있어서 글 마무리를 미루다가 얼렁뚱땅 프로젝트 글을 마쳤다. electron 으로 개발한 첫 번째 어플리케이션이라 애착이 많이 간다. 크게 어려운 코드가 없기 때문에 기존에 Node.js 를 알고 있는 개발자라면 코드를 읽는 데 전혀 어려움이 없을 것이다. 자세한 소스 코드는 <a href="https://github.com/dgjung0220/adb_viewer">github</a> 을 참고하길 바란다.</span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/07/cpu-usage-cgroup-cpusets-viewer2/" title="10:25 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-07T22:25:27+00:00">2017년 8월 7일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/07/cpu-usage-cgroup-cpusets-viewer2/#respond">댓글 남기기</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-263" class="no-thumbnail post-263 post type-post status-publish format-standard hentry category-blog category-kernel tag-kernel">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/06/2-kernel-build-modules/" rel="bookmark">2. Kernel Build</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">지난 시간에 최신 커널을 다운로드하는 것까지 수행하였다. 이제 커널의 트리 구조를 살펴보고, 하나씩 간단하게 알아보자.</span></p>
<p>1. 커널 하위 트리</p>
<ul>
<li><span style="font-size: 10pt;"><strong>arch </strong>아키텍처에 밀접한 파일을 담고 있다. arch/ 아래에 ARM, IA64, sparc, x86 같이 프로세서마다 독자적인 하위 디렉터리가 있다.</span></li>
<li><span style="font-size: 10pt;"><strong>block</strong> 주로 블록 저장소 디바이스용 입출력 스케줄링 알고리즘 구현이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>crypto</strong> 암호 연산과 API를 구현한다. </span></li>
<li><span style="font-size: 10pt;"><strong>Documentation </strong>커널 하위 시스템에 대한 간략한 설명을 담고 있다. 구글링 전에 이 문서를 살펴보고 구글링하면 대부분의 정보가 이미 커널에 문서화되있음을 알 수 있다.</span></li>
<li><span style="font-size: 10pt;"><strong>drivers</strong> 다양한 디바이스 클래스와 주변 장치 컨트롤러가 위치한다. 디바이스 드라이버 클래스는 <strong>문자</strong>, <strong>시리얼</strong>, <strong><a href="https://ko.wikipedia.org/wiki/I%C2%B2C">I2C</a></strong>, <a href="https://ko.wikipedia.org/wiki/PC_%EC%B9%B4%EB%93%9C">PCMCIA</a>, <a href="https://ko.wikipedia.org/wiki/PCI_%EB%B2%84%EC%8A%A4">PCI</a>, <strong>USB</strong>, 비디오, <strong>오디오</strong>, <strong>블록</strong>, <a href="https://ko.wikipedia.org/wiki/%EB%B3%91%EB%A0%AC_ATA">IDE</a>, <a href="https://ko.wikipedia.org/wiki/SCSI">SCSI</a>, CD-ROM, 네트워크 어댑터, <a href="https://ko.wikipedia.org/wiki/%EB%B9%84%EB%8F%99%EA%B8%B0_%EC%A0%84%EC%86%A1_%EB%B0%A9%EC%8B%9D">ATM</a>, <strong>블루투스</strong>, <a href="https://en.wikipedia.org/wiki/Memory_Technology_Device">MTD </a>등이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>fs</strong> EXT3, EXT4, FAT, VFAT, sysfs, procfs, NTFS 같은 파일 시스템 구현과 관련된 내용이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>include</strong> 커널 헤더 파일이 여기에 위치한다. asm 접두어가 붙은 하위 디렉터리에는 특정 아키텍처와 관련 있는 헤더가 들어있다. 예를 들어 asm-x86 에는 x86 아키텍처용 헤더 파일이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>init</strong> 상위 단계 초기화와 시작 코드가 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>ipc</strong> message queue, semaphore, shared memory 같은 IPC(Inter-Process Communication) 메커니즘이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>kernel</strong> 아키텍처 중립적인 부분이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>lib</strong> 일반적인 kobject 처리, CRC 계산 함수 등의 라이브러리 루틴이 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>mm</strong> 메모리 관리 구현체가 들어있다.</span></li>
<li><span style="font-size: 10pt;"><strong>net</strong> 네트워크 프로토콜. (IPv4, IPv6, IPX, 블루투스, ATM, 적외선, LAPB, LLC)</span></li>
<li><span style="font-size: 10pt;"><strong>scripts</strong> 커널 빌드에 사용할 스크립트</span></li>
<li><span style="font-size: 10pt;"><strong>security</strong> 보안용 프레임워크가 위치한다.</span></li>
<li><span style="font-size: 10pt;"><strong>sound</strong> 리눅스 오디오 하위 시스템이 위치한다.</span></li>
<li><span style="font-size: 10pt;"><strong>usr</strong> initramfs 가 위치한다.</span></li>
</ul>
<p><span style="font-size: 10pt;">구글에 리눅스 커널 트리 구조라고 검색하면, 다양한 설명을 그림과 함께 볼 수 있다. 예를 들면, <a href="https://www.slideshare.net/icanjji/100-12">참고&#8230;</a>  한 번쯤 다 설명을 적어둬야겠다는 생각을 했는데, 이렇게 다 써보니 지루하다&#8230; </span></p>
<p>2. 커널 빌드하기</p>
<p><span style="font-size: 10pt;">상위 단계 초기화 및 시작 코드가 들어 있는 init 디렉터리에 들어가 main.c 에 코드 변경 후, 커널 빌드를 해보자. main.c 에 가면, 커널의 시작인 start_kernel 함수를 찾을 수 있다. 여기에 printk 로 적고 싶은 글을 적어보자.</span></p>
<pre class="lang:default decode:true">asmlinkage __visible void __init start_kernel(void)
{
        char *command_line;
        char *after_dashes;

        printk("Bearpot.net - Donggoo Jung\n");
        set_task_stack_end_magic(&amp;init_task);
        ...</pre>
<p><span style="font-size: 10pt;">이제 변경된 코드로 빌드를 해볼 때가 되었다.</span></p>
<pre class="nums:false lang:default decode:true ">$ make menuconfig
$ cp arch/x86/configs/x86_64_defconfig .config
$ make bzImage</pre>
<p><span style="font-size: 10pt;">menuconfig 는 텍스트 인터페이스로 동작하는 커널 설정 메뉴다. 이 외에는 xconfig (나름 GUI) 등이 있다. 선택한 설정 정보는 루트 디렉터리의 .config 파일에 저장된다. 하지만 설정 내용이 엄청나게 길다. 다 읽어보고 하나씩 설정한다면, 빌드를 언제 해볼 수 있을지&#8230;. 그래서 두번째 줄의 defconfig 파일을 .config로 복사하여 사용한다. 그리고 마지막 명령어로 커널 부트 이미지를 생성한다. 빌드가 완료되면, <strong>arch/x86_64/boot/bzImage </strong>로 만들어진다. 다음으로 할 것은 부트 파티션을 업데이트하고 리붓하여 부팅하는 것이다.</span></p>
<pre class="lang:default decode:true">$ cp arch/x86_64/boot/bzImage /boot/vmlinuz-4.12.4
$ reboot</pre>
<p><span style="font-size: 10pt;">정상적으로 완료했다면 부팅의 첫 메시지에서 앞서 printk 로 적어주었던 메시지로 시작하는 것을 확인할 수 있을 것이다.</span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/06/2-kernel-build-modules/" title="11:33 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-06T23:33:02+00:00">2017년 8월 6일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/kernel/" rel="tag">kernel</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/06/2-kernel-build-modules/#respond">댓글 남기기</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-253" class="no-thumbnail post-253 post type-post status-publish format-standard hentry category-blog category-imgoverflow-io category-nodejsmongodb tag-imgoverflow-io tag-mongoose tag-node-js">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/" rel="bookmark">imgOverflow.io(5)-Mongoose(2)</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;"><a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/">지난 시간</a> 에 이해 몽구스의 특징인 내장 검증, 정적 메소드, 가상 프로퍼티에 대해서 알아보겠다.</span></p>
<p><span style="font-size: 14pt;">1. 내장 검증</span></p>
<p><span style="font-size: 10pt;">몽구스의 핵심은 위에서 설명한 스키마 구조다. 일반적으로 NoSQL은 스키마 구조를 가지지 않는다. (OrientDB  의 경우에는 NoSQL인데도 기본적으로 스키마과 관계를 정의하고 있다. 다음에 정리하겠다. OrientDB 추천&#8230;) 스키마 구조를 정의함으로써 검증 기능을 사용할 수 있다. 기본적으로 모든 스키마 타입은 필수 요소 검증기를 사용할 수 있다. 그 외에 숫자 형식은 min, max 검증기, 문자열은 열거형, 매칭 검증기를 가지고 있다. 뿐만 아니라 사용자 정의 검증기도 만들어 스키마에 선언할 수 있다. required 를 이용하여 검증기를 사용해보자.</span></p>
<pre class="lang:default decode:true">var robot = new Schema({
  name : {type: String, required: true},
  birth : {type: Date, default: Date.now},
  sex : {type: Number, default: 0}, // 0 - male 1 - female
  activate : {type: Boolean, default: true},
  frequency : {type: Number, required: true, min: 307200, max: 2152000}
});</pre>
<p><span style="font-size: 10pt;">name 문자열에 <strong>required: true </strong>를 사용함으로써, name 인자를 필수 요소로 설정하고, frequency 라는 필드를 추가하여, frequency<strong> </strong>가 min 307200 ~ max 2152000 사이 값을 가지도록 설정했다. 만약 입력된 값이 이 조건에 만족하지 않는다면, 에러가 발생하고 값은 DB에 저장되지 않는다. Save 함수를 호출하면 자동적으로 내부 검증이 이루어 지는데, 콜백 함수를 이용하여 직접적으로 내부 검증을 실시할 수도 있다.</span></p>
<pre class="lang:default decode:true">var robotModel = mongoose.model('robot', robot);
var newRobot = new robotModel({name : 'I-1', frequency: 30000000});
/* validate 함수를 직접 호출하여 내부 검증을 실시*/
newRobot.validate(function(err) {
  console.log(err);
});</pre>
<p><span style="font-size: 10pt;">위의 코드를 실행하면, error 객체를 반환하게 되는데, errors.message 를 살펴 보면&#8217;frequency&#8217; (30000000) is more than maximum allowed value 라는 메시지를 확인할 수 있을 것이다. error 객체의 반환 값을 이용하여, 사용자에게 에러 코드를 반환할 수도 있으니 잘 활용하도록 하자.</span></p>
<p>2. 정적 메소드</p>
<p><span style="font-size: 10pt;">스키마는 자신 스키마에서 생성된 모든 모델에서 사용 가능한 커스텀 정적 메소드를 추가할 수 있다. 이는 모든 모델에서 사용될 것 같은 헬퍼 유틸리티나 함수를 추가하는데 유용하게 쓰인다. 아래의 코드를 보면 쉽게 이해된다.</span></p>
<pre class="lang:default decode:true">var Robot = new Schema({
  name : {type: String, required: true},
  birth : {type: Date, default: Date.now},
  sex : {type: Number, default: 0}, // 0 - male 1 - female
  activate : {type: Boolean, default: true},
  frequency : {type: Number, required: true, min: 307200, max: 2152000}
});

Robot.statics.findBySex = function(key, callback) {
  this.find({sex : key}, callback);
};</pre>
<pre class="lang:default decode:true ">var robotModel = mongoose.model('Robot', Robot);
robotModel.findBySex(0, function(err, robots){
  /* male(0) 인 robot 의 목록을 출력 */
  console.log(robots.length); 
})</pre>
<p>&nbsp;</p>
<p>3. 가상 프로퍼티</p>
<p><span style="font-size: 10pt;">Virtual Property 는 말 그대로 실제 존재하진 않지만, 다른 프로퍼티와 혼재하여 사용할 수 있는 프로퍼티이다. 아래의 예제를 살펴보자.</span></p>
<pre class="lang:default decode:true ">var Robot = new Schema({
  name : {type: String, required: true},
  code : {type: String, required: true},
  birth : {type: Date, default: Date.now},
  sex : {type: Number, default: 0}, // 0 - male 1 - female
  activate : {type: Boolean, default: true},
  frequency : {type: Number, required: true, min: 307200, max: 2152000}
});

Robot.virtual('ID').get(function() {
  return this.name + ':' + this.code;
}).set(function(ID) {
  this.name = ID.split(':')[0];
  this.code = ID.split(':')[1];
})</pre>
<p><span style="font-size: 10pt;">예제에서는 name, code 필드를 이용하여 ID 라는 가상 프로퍼티를 만들었다. Set &amp; Get 함수를 호출하는데, get 의 경우 문자열을 연결해 새로운 값을 반환하고, set은 : 으로 입력받은 문자열을 분리해서 name 과 code 필드에 각각 값을 할당한다. <strong>주의할 점은 가상 프로퍼티는 실제 도큐먼트나 컬렉션의 필드가 아니기 때문에 mongodb에 영속되지 않는다.</strong></span></p>
<p>4. 마무리</p>
<p><span style="font-size: 10pt;">몽구스의 간단한 사용법 (save, find, Schema 생성) 및 대표적인 특징들을 살펴 보았다. 몽구스는 이 외에도 더 많은 기능을 제공하고 있다. 몽구스를 사용하면서 시간이 나면 <a href="http://mongoosejs.com/docs/guide.html">몽구스 문서</a> 를 참고하도록 하자.</span></p>
<p><span style="font-size: 8pt;">덧, 몽구스는 몽구스과의 귀여운 동물이다. 미어캣도 몽구스과다!!!</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 10pt;">※ 원문.</span><a href="https://www.packtpub.com/big-data-and-business-intelligence/web-development-mongodb-and-nodejs-second-edition"><span style="font-size: 10pt;"> Web Development with MongoDB and NodeJS </span></a></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/" title="12:29 오전" rel="bookmark"><time class="entry-date" datetime="2017-08-06T00:29:24+00:00">2017년 8월 6일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/imgoverflow-io/" rel="tag">imgOverflow.io</a>, <a href="http://bearpot.net/blog/tag/mongoose/" rel="tag">mongoose</a>, <a href="http://bearpot.net/blog/tag/node-js/" rel="tag">node.js</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/#comments">댓글 한 개</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-250" class="no-thumbnail post-250 post type-post status-publish format-standard hentry category-blog category-imgoverflow-io category-nodejsmongodb tag-imgoverflow-io tag-mongoose tag-node-js">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/" rel="bookmark">imgOverflow.io(4)-Mongoose(1)</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">Node.js 에서 mongodb를 사용하는 예제를 다룬 적이 있다. 좋은 방법이긴 하나, 좀 더 편하고 스마트하게 mongodb 를 사용할 수 있는 서드파티 프레임워크가 존재한다. <a href="http://mongoosejs.com/">Mongoose</a>(이하 &#8216;몽구스&#8217;)  홈페이지에 접속하면 <strong>&#8216;</strong><em><strong>elegant mongodb object modeling for node.js&#8217;</strong> </em>라는 설명으로 시작한다. 말그대로 몽구스는 </span><span style="font-size: 10pt;">mongodb 와의 작업을 효율적으로 만들어 줄뿐만 아니라, Node.js 객체 모델링을 제공한다. 기본적으로 몽구스를 이용해 어플리케이션의 DB를 스카마를 사용해 구조화할 수 있고, 모델에 검증이나 가상 프로퍼티 같은 강력한 기능을 제공한다. </span></p>
<p>1. 스키마</p>
<p><span style="font-size: 13.3333px;">컴공이라면 학부 때 데이터베이스 시스템 과목을 수강하면서 스키마라는 단어를 들어봤을 것이다. (듣지 않았다면, <a href="http://www.yes24.com/24/goods/3423280?scode=032&amp;OzSrank=18">이 책</a>을 추천한다.) 스키마란 데이터베이스의 논리적 정의, 다시 말해서 데이터베이스 구조(Structure)와 제약 조건(Constraints)에 대한 명세(Specification)를 기술한 것이다. 일종의 청사진이라고 생각하면 편하다. 이 스키마를 이용해 몽구스에서는 기본적인 스키마의 정의뿐만 아니라, 내장 검증 기능과 정적 메소드, 가상 프로퍼티 등을 지원한다. </span></p>
<p><span style="font-size: 10pt;">스키마 정의의 첫 번 째 작업은 도큐먼트 내의 필드 목록을 정의하는 것이다. 각 필드들은 이름과 타입을 기술하는데, 기본적으로 아래와 같은 데이터 타입들이 몽구스에서 제공된다.</span></p>
<ul style="list-style-type: square;">
<li><span style="font-size: 10pt;"><strong>String</strong> 문자열을 저장한다</span></li>
<li><span style="font-size: 10pt;"><strong>Number</strong> 제한된 숫자를 저장한다.</span></li>
<li><span style="font-size: 10pt;"><strong>Date</strong> 시간 오브젝트를 저장한다.</span></li>
<li><span style="font-size: 10pt;"><strong>Buffer</strong> </span></li>
<li><span style="font-size: 10pt;"><strong>Boolean</strong> Bool(True/False) 값을 저장한다.</span></li>
<li><span style="font-size: 10pt;"><strong>Mixed</strong> 아무거나 저장 가능. 임의적이거나 문자열 그대로 JSON 형식인 객체를 저장할 때 주로 사용된다.</span></li>
<li><span style="font-size: 10pt;"><strong>ObjectID</strong> 일반적으로 다른 도큐먼트의 필드에 있는 ObjectID를 저장하는데, 다른 도큐먼트와의 관계를 정의할 때 사용된다. 일종의 Key</span></li>
<li><span style="font-size: 10pt;"><strong>Array</strong> 다른 스키마들의 모음</span></li>
</ul>
<p><span style="font-size: 10pt;">기본적으로 Node.js 에서 몽구스의 스키마 정의 형태는 아래와 같다. 아래에서는 로봇의 데이터를 스키마로 정의하고 있다. 기존 관계형 데이터베이스를 다뤄봤던 사람들은 척하면 이해가 될 것이다.</span></p>
<pre class="lang:default decode:true">var mongoose = require('mongoose');
var Schema = mongoose.Schema;

var Robots = new Schema({
  name : {type: String},
  birth : {type: Date, default: Date.now},
  sex : {type: Number, default: 0}, // 0 - male, 1 - female
  activate : {type: Boolean, default: true}
})</pre>
<p>&nbsp;</p>
<p>2. 모델</p>
<p><span style="font-size: 10pt;">몽구스에서 모델은 스키마에 의해 구체화되는 클래스이다. 스키마를 사용하여 모델을 정의하고 js 객체로 사용할 수있다.</span> <span style="font-size: 10pt;">모델 객체의 장점은 CRUD 기능이 포함한다. 아래와 같이 모델을 정의하고 구체화한다.</span></p>
<pre class="lang:default decode:true ">var mongoose = require('mongoose');
var Schema = mongoose.Schema;

mongoose.connection.openUri('mongodb://localhost:27017/Robotsfactory');
mongoose.connection.on('open', function() {
  console.log('[Mongoose] Connected to Robots Factory Database.')
});

var robot = new Schema({
  name : {type: String},
  birth : {type: Date, default: Date.now},
  sex : {type: Number, default: 0}, // 0 - male 1 - female
  activate : {type: Boolean, default: true}
});

var robotModel = mongoose.model('robot', robot);
var newRobot = new robotModel({name : 'R-16'});

/* Check */
console.log(newRobot.name);
console.log(newRobot.birth);
console.log(newRobot.sex);
console.log(newRobot.activate);</pre>
<p><span style="font-size: 10pt;">실행 결과는 아래와 같다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">$ node index
R-16
Sat Aug 05 2017 22:47:01
0
true</pre>
<p><span style="font-size: 10pt;">몽구스에서는 mongodb의 insert나 update를 위해서 <strong>save</strong> 함수를 사용한다. 마찬가지로 find 함수는 <strong>.find() </strong>로 사용하면 된다.</span></p>
<pre class="lang:default decode:true">/* 새로운 로봇을 정의하고 DB에 저장한다.*/
var robotModel = mongoose.model('robot', robot);
var newRobot = new robotModel({name : 'I-1'});
newRobot.save();

/* 모든 로봇의 목록을 출력한다.*/
robotModel.find();</pre>
<p>&nbsp;</p>
<p>3. 마무리</p>
<p><span style="font-size: 10pt;">Node.js 에서 mongodb 를 효율적으로 사용할 수 있는 몽구스의 스키마 정의 및 저장, 출력 방법을 알아보았다. 앞서 소개한 몽구스의 추가적인 기능들 (내장 검증, 정적 메소드, 가상 프로퍼티) 는 다음 시간에 추가적으로 정리하겠다. </span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 10pt;">※ 원문.<a href="https://www.packtpub.com/big-data-and-business-intelligence/web-development-mongodb-and-nodejs-second-edition"> Web Development with MongoDB and NodeJS </a></span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/" title="11:02 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-05T23:02:07+00:00">2017년 8월 5일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/imgoverflow-io/" rel="tag">imgOverflow.io</a>, <a href="http://bearpot.net/blog/tag/mongoose/" rel="tag">mongoose</a>, <a href="http://bearpot.net/blog/tag/node-js/" rel="tag">node.js</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/#comments">댓글 한 개</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-239" class="no-thumbnail post-239 post type-post status-publish format-standard hentry category-blog category-imgoverflow-io category-nodejsmongodb tag-imgoverflow-io tag-node-js tag-35 tag-34">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/05/imgoverflow-io3-handlebar-helper/" rel="bookmark">imgOverflow.io(3)-handlebar helper</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">핸들바는 핼퍼라는 개념을 가지고 있다. 핼퍼는 특유의 커스텀 함수로서 런타임 시에 템플릿 내부에서 실행되는 특수한 로직을 구현할 수 있다. 따라서 해당 기능을 사용하면, 전역적으로 공통된 로직을 핼퍼로 만들어서 재사용할 수도 있고, 뷰마다 따로 정의하여 viewModel 로 템플릿에 넘겨줄 수 있다.</span></p>
<p>1. 전역 헬퍼</p>
<p><span style="font-size: 10pt;">타임스탬프 값을 이용하여 이벤트 발생 후, 얼마나 지났는지 표시하는 전역 모듈을 만들어 보자. 이 헬퍼는 댓글이나 이미지 등의 업로드 컨텐츠에 대해 타임스탬프를 표시해줄 수 있다. 앞서 소개했던 핸들바를 렌더링 엔진으로 설정하는 부분에 추가로 helpers 를 설정해준다.</span></p>
<pre class="lang:default mark:5-10 decode:true">app.engine('handlebars',exphbs.create({
        defaultLayout: 'main',
        layoutsDir: app.get('views') + '/layouts',
        partialsDir: [app.get('views') + '/partials'],
        helpers: {
            timeago: function(timestamp) {
                console.log(timestamp);
                return moment(timestamp).startOf('minute').fromNow();
            }
        }
}).engine);
app.set('view engine', 'handlebars');</pre>
<p><span style="font-size: 10pt;">create() 함수 내에서 helpers 프로퍼티를 추가했다. 이 안에는 원하는 만큼 함수를 정의할 수 있다.  여기에 timeago 함수를 정의하는데, <strong>moment(다양한 종류의 날짜와 관련된 문자열 연산을 제공)</strong> 라는 node 모듈을 이용하여 시간을 리턴하고 있다.</span></p>
<p>2. 뷰 핼퍼</p>
<p><span style="font-size: 10pt;">단일 뷰에서만 사용할 수 있는 헬퍼를 정의할 수 있다. res.render() 함수를 실행할 때 viewModel에 핼퍼를 구현할 수 있는데, 이를 이용해 템플릿으로 넘겨준다.</span></p>
<pre class="lang:js decode:true">var viewModel = {
  name : 'Donggoo Jung',
  homepage : 'bearpot.net',
  project :  'olivePanda',
  helpers : {
    timeago : function(timestamp) {
      return 'timestamp';
    }
  }
};

res.render('index', viewModel);
</pre>
<p>&nbsp;</p>
<p><span style="font-size: 10pt;">※ 원문.<a href="https://www.packtpub.com/big-data-and-business-intelligence/web-development-mongodb-and-nodejs-second-edition"> Web Development with MongoDB and NodeJS </a></span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/05/imgoverflow-io3-handlebar-helper/" title="9:47 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-05T21:47:53+00:00">2017년 8월 5일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/imgoverflow-io/" rel="tag">imgOverflow.io</a>, <a href="http://bearpot.net/blog/tag/node-js/" rel="tag">node.js</a>, <a href="http://bearpot.net/blog/tag/%ed%95%b8%eb%93%a4%eb%b0%94/" rel="tag">핸들바</a>, <a href="http://bearpot.net/blog/tag/%ed%95%b8%eb%93%a4%eb%b0%94-%ed%95%bc%ed%8d%bc/" rel="tag">핸들바 핼퍼</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/05/imgoverflow-io3-handlebar-helper/#respond">댓글 남기기</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-209" class="no-thumbnail post-209 post type-post status-publish format-standard hentry category-blog category-imgoverflow-io category-nodejsmongodb tag-imgoverflow-io tag-multer">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/03/imgoverflow-io2-multer/" rel="bookmark">imgOverflow.io(2)-multer</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">웹페이지에서 파일 업로드를 처리하는 데이터 양식은 multipart 이다.  하지만 body-parser 는 JSON, URL 인코딩 형식 데이터 입력만 지원한다. 그렇기 때문에 추가적으로 multipart 양식을 지원하는 multer 라는 모듈을 이용한다.</span></p>
<p>1. 모듈 설치 및 선언</p>
<pre class="nums:false lang:default highlight:0 decode:true">$ npm install --save multer</pre>
<pre class="lang:default decode:true">"dependencies": {
    "multer": "^1.3.0"
}</pre>
<p><span style="font-size: 10pt;">multer 모듈을 설치하고, package.json을 확인하면 위와 같이 추가되어 있는 것을 확인할 수 있다. </span></p>
<pre class="lang:default decode:true">var multer = require('multer');
var upload = multer({ dest: path.join(__dirname, 'public/upload/temp')});
</pre>
<p><span style="font-size: 10pt;">multer 모듈을 사용하도록, require 코드를 추가하고, 임시로 저장될 multipart 데이터를 보관할 path 를 지정해준다.</span></p>
<p>2. Multipart 형식</p>
<p><span style="font-size: 10pt;">route에서 request 를 통해 받은 multipart의 데이터를 살펴보면 아래와 같은 데이터 형식으로 이루어져 있다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">{ fieldname: 'file',
  originalname: 'Capture001.png',
  encoding: '7bit',
  mimetype: 'image/png',
  destination: 'C:\\workspace\\js_workspace\\nodejs\\nodejs&amp;mongodb\\imgPloadr.io\\server\\public\\upload\\temp',
  filename: 'e3a81a6851852e6dbe771c86af8e4fe6',
  path: 'C:\\workspace\\js_workspace\\nodejs\\nodejs&amp;mongodb\\imgPloadr.io\\server\\public\\upload\\temp\\e3a81a6851852e6dbe771c86af8e4fe6',
  size: 2623663 }</pre>
<p>&nbsp;</p>
<p>3. Unique Key 생성</p>
<p><span style="font-size: 10pt;">originalname 을 통해 업로드한 파일 이름을 확인할 수 있지만, 이를 이용해서 저장하지는 않을 것이다. 후에 몽고DB를 이용할 때 이름을 이미지의 고유 식별자로 이용할 수 있도록 임의의 문자열을 생성하는 함수를 만들어준다. 아래의 getUniqueKey는 알파벳 소문자 및 숫자를 조합하여 6자리의 고유한 키값을 생성한다.</span></p>
<pre class="lang:default decode:true">var getUniqueKey = () =&gt; {
  var possible = 'abcdefghijklmnopqrstuvwxyz0123456789',
  unique = '';

  for (var i = 0; i &lt; 6; i++) {
    imgUrl += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return unique;
}</pre>
<p>&nbsp;</p>
<p>4. 저장</p>
<p><span style="font-size: 10pt;">최초 upload 한 이미지 파일은 위의 데이터 형식에서 확인할 수 있듯이, multer에서 지정한 path에 저장된다. 이 path를 tempPath로 지정하고, 실제 원하는 위치(express.static으로 지정한 폴더) 에 저장할 수 있도록 아래와 같이 처리한다. 또한 실제로는 이미지 파일만 처리해줄 수 있도록 .png, .jpg 등 확장파일명을 검사하는 조건문을 추가한다.</span></p>
<pre class="lang:default decode:true">var tempPath = req.file.path;
var ext = path.extname(req.file.originalname).toLowerCase();
var targetPath = path.resolve('./public/upload/' + imgUrl + ext);

if (ext === '.png' || ext === '.jpg' || ext === '.jpeg' || ext === '.gif') {
  fs.rename(tempPath, targetPath, function(err) {
    if(err) {throw err;}
  });
  console.log('Successfully inserted image : ' + image.filename);
} else {
  fs.unlink(tempPath, function() {
    if (err) throw err;
    res.json(500, {error: 'Only image files are allowed.'});
  })
}</pre>
<p><span style="font-size: 10pt;">두번째 줄의 extname 함수는 파일 이름에서 확장파일명만을 반환한다. 확장파일명을 비교하여 이미지 파일이 맞다면, fs.rename 함수를 이용하여 tempPath의 파일을 targetPath 로 복사한다. 이미지 파일이 아니라면, path를 unlink 한다. 리눅스 등의 OS의 경우, 프로젝트 폴더 내에서 파일을 만드는 수행이 권한 문제로 성공하지 못 할수도 있다. 실제 생성되는지 반드시 확인하자.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 10pt;">※ 원문.<a href="https://www.packtpub.com/big-data-and-business-intelligence/web-development-mongodb-and-nodejs-second-edition"> Web Development with MongoDB and NodeJS </a></span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/03/imgoverflow-io2-multer/" title="7:06 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-03T19:06:33+00:00">2017년 8월 3일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/imgoverflow-io/" rel="tag">imgOverflow.io</a>, <a href="http://bearpot.net/blog/tag/multer/" rel="tag">multer</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/03/imgoverflow-io2-multer/#comments">댓글 한 개</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-201" class="no-thumbnail post-201 post type-post status-publish format-standard hentry category-blog category-webvr tag-m2p tag-vr">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/03/m2p-latency-%ec%9d%b4%ec%95%bc%ea%b8%b01/" rel="bookmark">M2P latency 이야기(1)</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">약 3년간 VR Platform (Device) Performance 개발자로 일하면서, VR의 성능에 관한 여러 가지 질문을 받았다. VR 성능 평가는 정성적, 정량적 평가가 모두 가능하지만 오늘 얘기해볼 것은 VR 성능 지표로 가장 많이 사용하는 M2P latency 에 대해서다.</span></p>
<p><span style="font-size: 10pt;">M2P latency (Motion to Photon latency) 는 VR 에서 실제 내 모션이 랜더링을 거쳐 디스플레이에 반영되는 시간을 말한다. 최초, 오큘러스에서는 M2P latency 의 성능 만족 범위를 20 ms 이내로 정했다. 이 범위를 만족하는 VR 해드셋은 오큘러스, 바이브, PS VR, 삼성 Gear VR 정도가 있다.</span></p>
<p><span style="font-size: 10pt;">애초에 오큘러스는 왜 M2P latency 의 성능 만족 범위를 20 ms 이내로 규정했을까. 이 것은 우리의 눈과 관련이 있다. 눈에는 시신경과 중심와(Fovea), 그리고 중심와를 기점으로 원추세포, 그 외 간상세포가 존재한다. 원추세포는 색상을 뚜렷하게 보여주고, 간상세포는 약한 빛을 감지하는 시세포다. 원추세포와 간상세포에 대해서는 VR 성능 지표 중 하나인 디스플레이 motion blur 에 대해 설명하면서 추가로 하겠다. 본론으로 돌아가서, M2P latency가 20ms 이내여야 하는 이유는 우리 인간이 사물을 눈으로 바라보았을 때, 중심와에 또렷이 초점이 형성되는 반응이 20ms 이내에 이루어지기 때문이다. 인간의 실제행동보다 VR 디스플레이 변화 속도가 느리다면, VR 사용자는 인지 부조화 등의 이유로 어지럽고 메스꺼움을 느낀다.</span></p>
<p><span style="font-size: 10pt;">앞서 M2P latency 는 VR을 착용하고 고개의 움직임 등 실제 모션 (센싱) 이 랜더링을 거쳐 디스플레이에 반영되는 시간을 의미한다고 말했다. 따라서 이 성능을 20ms 이내로 맞추기 위해서는 센서(센싱), 랜더링(CPU, GPU), 디스플레이(패널 종류 및 응답속도) 의 HW, SW 기술이 중요하다.</span></p>
<p><span style="font-size: 10pt;">고성능의 VR 헤드셋들은 800 ~ 1000 hz 로 동작하는 IMU Sensor unit 을 사용한다. 따라서 센싱에 걸리는 latency 는 약 1ms(1000hz) 가 된다. 랜더링의 경우에는 디스플레이가 나가는 시간 내에만 이루어지면 되는데, 고성능의 디바이스들은 보통 100hz ~ 120hz 로 디스플레이가 랜더링 된다. (Driver IC 동작 frequency 에 기인.) 따라서 8.3ms ~ 10ms 내에 랜더링이 이루어져야 한다. (Front Buffer Rendering 기준). 마지막으로 디스플레이의 응답 속도가 최종적으로 M2P latency에 영향을 미치는 데, 응답속도란 디스플레이에서 화면이 얼마나 빨리 출력될 수 있는가를 수치로 표현한 것이다. 응답 속도의 경우 패널마다 기술차로 다를 수 있지만 OLED 의 경우 1ms, LCD 의 경우 GTG(Gray To Gray) 기준 최소 18ms 에서 35ms가 소요될 수 있다. LCD 패널을 사용하게 될 경우 디스플레이 응답속도에서만 이미 M2P 성능 기준을 만족하지 못 하게 되므로, 현재 기술로는 VR 헤드셋에는 반드시  OLED를 사용해야 한다는 결론이 나온다.  따라서 최선의 경우인 </span><span style="font-size: 10pt;">1000hz 센서, 100hz 랜더링, 그리고 1ms의 응답 속도를 가진 OLED를 사용했을 때의 M2P latency는 아래와 같다. (tearing 없이 front buffer rendering으로 vsync 타이밍에 랜더링이 완벽하게 이루어진다고 가정)</span></p>
<p style="text-align: center;"><span style="font-size: 10pt;"><em>M2P latency(<strong>12ms</strong>) = Sensing(1ms) + Rendering(10ms) + Display(1ms)</em></span></p>
<p><span style="font-size: 10pt;">좋은 하드웨어를 사용하면 성능 개선할 것도 없이 기준 성능을 훨씬 만족한다. 삼성 Gear VR의 경우는 어떨까. Gear VR은 특성상 안드로이드의 센서를 이용하는 안드로이드 임베디드형 해드셋이다. 따라서 삼성 Gear VR은 250hz로 동작하는 IMU 센서, 60hz 랜더링(안드로이드는 Surfaceflinger가 60hz로 동작하여 vsync가 나간다.) 그리고 1ms 의 응답 속도를 가진 VR 헤드셋 장비다.</span></p>
<p style="text-align: center;"><span style="font-size: 10pt;"><em>Gear VR M2P latency 예상(<strong>21.7ms</strong>) = Sensing(4ms) + Rendering(16.7ms) + Display(1ms)</em></span></p>
<p><span style="font-size: 10pt;">삼성 Gear VR은 21.7ms로 20ms 이내를 만족하지 않지만, 얼추 비슷하다. 삼성 휴대폰이 OLED를 썼기에 망정이지, 기타 LCD를 사용하는 안드로이드 폰으로 VR을 즐길 경우, 디스플레이 응답속도는 최대 35ms로 늘어나기 때문에, 아래와 같은 latency가 측정될 것이다.</span></p>
<p style="text-align: center;"><span style="font-size: 10pt;"><em>LCD Panel M2P latency 예상(<strong>55.7ms</strong>) = Sensing(4ms) + Rendering(16.7ms) + <strong><span style="color: #ff0000;">Display(~&lt;35ms)</span></strong></em></span></p>
<p><span style="font-size: 10pt;">안드로이드 디바이스의 VR 기기로써의 희망은 없을까. 삼성도 20ms 이내라고 했는데 예상 수치는 20ms를 넘는다. 이를 해결하기 위해서 Timewarp 라는 기술을 사용하는데 이는 랜더링 타임을 50% 정도 감소시킬 수 있는 기술이다. Timewarp 을 사용하는 경우 Gear VR의 latency는 약 13ms가 예상된다. 다음 번에는 Timewarp 에 대해 설명하도록 하겠다.</span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/03/m2p-latency-%ec%9d%b4%ec%95%bc%ea%b8%b01/" title="12:12 오전" rel="bookmark"><time class="entry-date" datetime="2017-08-03T00:12:50+00:00">2017년 8월 3일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/m2p/" rel="tag">M2P</a>, <a href="http://bearpot.net/blog/tag/vr/" rel="tag">VR</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/03/m2p-latency-%ec%9d%b4%ec%95%bc%ea%b8%b01/#respond">댓글 남기기</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-198" class="no-thumbnail post-198 post type-post status-publish format-standard hentry category-blog category-imgoverflow-io tag-errorhandler tag-handlebars tag-imgoverflow-io tag-method-override tag-morgan">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/02/imgoverflow-io-1/" rel="bookmark">imgOverflow.io (1)</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p>1. imgOverflow.io</p>
<p><span style="font-size: 10pt;">책에서 소개하고 있는 웹앱은 imgPloadr.io 지만, 똑같은 이름으로 똑같이 개발하면 재미도 없고, 항상 Stack Overflow 는 켜져 있기에&#8230; imgOverflow.io 로 이름을 정했다.</span></p>
<p><span style="font-size: 10pt;">앞으로 만들 이 웹앱에서의 요구 사항은 아래와 같다.</span></p>
<ul>
<li><span style="font-size: 10pt;">1. 이미지 업로드 &amp; 최신 순서로 이미지 정렬.</span></li>
<li><span style="font-size: 10pt;">2. 이미지 클릭시 제목 및 설명과 함께 이미지를 확대.</span></li>
<li><span style="font-size: 10pt;">3. 사이드바를 통해 댓글, 인기 포스트, 상태 등을 노출.</span></li>
</ul>
<p>2. package.json</p>
<pre class="nums:false lang:default highlight:0 decode:true">$ npm install --save express
$ npm install --save morgan
$ npm install --save body-parser
$ npm install --save cookie-parser
$ npm install --save method-override
$ npm install --save errorhandler
$ npm install --save express-handlebars
</pre>
<p><span style="font-size: 10pt;">각 모듈에 대해서 간단히 설명하면 아래와 같다.</span></p>
<ul>
<li><span style="font-size: 10pt;">express : node.js 용 Web MVC 프레임워크</span></li>
<li><span style="font-size: 10pt;">morgan : 로깅 모듈로써, node.js 의 서버 디버깅에 유용하다.</span></li>
<li><span style="font-size: 10pt;">body-parser : post 요청을 통해 제출된 양식을 처리</span></li>
<li><span style="font-size: 10pt;">method-override : 구형 브라우저를 위한 REST API 지원 모듈</span></li>
<li><span style="font-size: 10pt;">cookie-parser : 쿠키를 사용하기 위한 모듈</span></li>
<li><span style="font-size: 10pt;">errorhandler : 전체 미들웨어 프로세스 중 어느 곳에서 발생하는 에러든지 처리할 수 있다. </span></li>
<li><span style="font-size: 10pt;">handlebars : pug(jade), ejs와 같은 템플릿 엔진. 일명 콧수염{{}}.</span></li>
</ul>
<p>3. index.js</p>
<p><span style="font-size: 10pt;">프로젝트의 시작점이다. 이름은 반드시 index 일 필요가 없다. (디폴트는 index, 많이 사용하는 것은 app.js or server.js 명명) </span></p>
<pre class="lang:default decode:true">var express = require('express');
var config = require('./server/configure');
var app = express();

app.set('port', process.env.PORT || 3000);
app.set('views', __dirname + '/views');  
app = config(app);</pre>
<p><span style="font-size: 10pt;">여기서는 configure 라는 config 모듈을 만들어서, 시작점을 간결하게 할 수 있다. 여기서 app 은 express에 의해 initiate 되는 변수인데, app 전체를 가리킨다.</span></p>
<p>4. configure.js</p>
<p><span style="font-size: 10pt;">앞서 package.json 에 포함시켰던 모듈들을 사용하기 위한 configure.js 를 정의한다.</span></p>
<pre class="lang:default decode:true">var path = require('path');
var route = require('./route');
var express = require('express');
var exphbs = require('express-handlebars');
var bodyParser = require('body-parser');
var cookieParser = require('cookie-parser');
var morgan = require('morgan');
var methodOverride = require('method-override');
var errorHandler = require('errorhandler');

module.exports = function(app) {
    app.use(morgan('dev'));
    app.use(methodOverride());
    app.use(cookieParser('some-secret-value-here'));

    app.use('/', route);
    
    app.use('/public/', express.static(path.join(__dirname, '../public')));
    if ('development' === app.get('env')) {
       app.use(errorHandler());
    }
    return app;
}</pre>
<p>5. route.js</p>
<p><span style="font-size: 10pt;">route.js 에서 router 변수를 선언하고, controllers 폴더의 컨트롤러를 불러와 경로에 할당한다. 아래는 순서대로 route.js &amp; home.js.</span></p>
<pre class="lang:js decode:true">var path = require('path');
var express = require('express');
var router = express.Router();

var home = require('../controllers/home');

router.get('/', home.index);

module.exports = router;</pre>
<pre class="lang:default decode:true ">module.exports = {
    index: function(req, res) {
        res.send('Homepage Index.');
    }
}</pre>
<p><span style="font-size: 10pt;">그냥 route.js 에서 컨트롤러의 역할을 모두 구현해버리면, route.js가 엄청 길어지고, restful 처리에도 코드를 알아보기 힘들어진다. controllers 라는 폴더를 만들어서 특정 로직의 컨트롤러들을 구현하면 코드의 가독성도 좋고, MVC 패턴에도 알맞다.</span></p>
<p>5. 핸들바</p>
<p><span style="font-size: 10pt;">handlebars.js 는 pug, ejs 같은 뷰 템플릿 엔진이다. 정적인 HTML 문서를 동적인 페이지로 바꿔 주는 랜더링 엔진인 셈이다. 원래 pug 를 자주 쓰는데 핸들바는 HTML 과 거의 동일하게 생겨서 복붙(?) 하기 편했다. 하지만 pug는 좀더 간결하게 빨리 작성할 수 있는 기분이라 무엇이 좋은지는 더 써봐야 할 것같다. 핸들바 사용을 위해서 핸들바를 기본 랜더링 엔진으로 등록한다. configure 모듈에 아래의 내용을 추가한다.</span></p>
<pre class="lang:default decode:true">app.engine('handlebars',exphbs.create({
    defaultLayout: 'main',
    layoutsDir: app.get('views') + '/layouts',
    partialsDir: [app.get('views') + '/partials'],
}).engine);
app.set('view engine', 'handlebars');</pre>
<p>&nbsp;</p>
<p><span style="font-size: 10pt;">※ 원문.<a href="https://www.packtpub.com/big-data-and-business-intelligence/web-development-mongodb-and-nodejs-second-edition"> Web Development with MongoDB and NodeJS </a></span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/02/imgoverflow-io-1/" title="7:00 오후" rel="bookmark"><time class="entry-date" datetime="2017-08-02T19:00:18+00:00">2017년 8월 2일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/errorhandler/" rel="tag">errorhandler</a>, <a href="http://bearpot.net/blog/tag/handlebars/" rel="tag">handlebars</a>, <a href="http://bearpot.net/blog/tag/imgoverflow-io/" rel="tag">imgOverflow.io</a>, <a href="http://bearpot.net/blog/tag/method-override/" rel="tag">method-override</a>, <a href="http://bearpot.net/blog/tag/morgan/" rel="tag">morgan</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/02/imgoverflow-io-1/#respond">댓글 남기기</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-186" class="no-thumbnail post-186 post type-post status-publish format-standard hentry category-blog category-webvr tag-android-debugging tag-chromium tag-webvr">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/08/02/webvr-%ea%b0%9c%ec%9a%94/" rel="bookmark">WebVR 개요</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 10pt;">7월 말, 진행 중인 VR 프로젝트와 관련하여, hardware agnostic 한 VR 플랫폼을 위해서 Web 지원 환경이라면 어디서든 사용할 수 있다고 하는 WebVR 에 대해 알아보았다. 하지만 짧은 시간에 조사하고 정리한 내용이라 사실과 다를수도 있다.</span></p>
<p>1. 개요 및 동향</p>
<p><span style="font-size: 10pt;">모질라 재단(Mozilla Foundation)에서 개발 및 정의하고 있다. (<a href="https://w3c.github.io/webvr/spec/1.1/">pre-release 2017.06.06</a>). 주로 사용하는 API는 <strong>WebVR API</strong><span style="font-size: 8pt;">(오브젝트 렌더링을 제외한 모든 요소가 포함된다.)</span>, <strong>Three.js</strong><span style="font-size: 8pt;">(선택, WebGL의 웹 전용 플러그인으로, 그대로 WebGL을 사용해도 상관없다.)</span>, 그리고 <strong>WebVR-polyfill</strong><span style="font-size: 8pt;">(선택, 안드로이드 디바이스에서 구글 카드보드와 같이 동작하도록 해주는 플러그인. 모질라과 구글의 협업으로 개발)</span> 이 있다.</span></p>
<p><span style="font-size: 10pt;">VR 디바이스의 각종 정보 관리 및 제어는 WebVR API를 이용하여 수행하게 되는데, 이는 웹브라우저에 종속적이다. 따라서 WebVR이 지원되는 브라우저를 사용해야 한다. (Chromium, Firefox Nightly, Chrome for Android 등, <a href="http://webvr.rocks">WebVR Rocks 참고</a>)</span></p>
<p>2. 개발 언어 / 개발 환경 설정</p>
<p><span style="font-size: 10pt;">개발 언어나 개발 환경에는 WebVR API 를 사용할 수 있는 환경이라면 뭐든지 가능하다. 기본적으로 Node.js, React.js 등으로 개발할 수 있었다. 기존에 Node.js 를 사용할 줄 아는 개발자라면 간단한 WebVR 공식 홈페이지의 설명만으로 사용할 수 있을 것이다. 아래는 WebVR starter project로 유명한 Boris 의 프로젝트 사용 방법이다.</span></p>
<pre class="nums:false lang:default decode:true ">Step1. Clone WebVR Boilerplate repo.

$ git clone https://github.com/borismus/webvr-boilerplate.git
$ npm install webvr-boilerplate

Step2. Spin up a local file server
$ cd webvr-boilerplate
$ python -m http.server 8000

</pre>
<p><span style="font-size: 10pt;">http://localhost:8000 으로 접속하면 빙글빙글 돌아가는 큐브와 함께 WebVR 을 경험할 수 있다. </span></p>
<p>3. Chromium webvr flag setting</p>
<p><span style="font-size: 10pt;">크로미움은 크롬의 개발자 버전으로, 크롬에 정식 탑재되기 전에 미리 탑재하여 개발 및 디버깅을 실시한다. 크로미움은 오픈 소스이기 때문에 소스 다운로드 및 컨트리뷰션이 가능하다. 크로미움 베이스로 개발된 국내엔 잘 알려지지 않은 브라우저들이 많은데 크롬,엣지 등 브라우저 삼대장에게 질렸을 때 사용해보면 색다른 기분이 든다.(비발디, 토치 등) 아무튼 크로미움을 다운받고 바로 webVR이 되는 것은 아니다. WebVR 개발 flag를 사용하도록 설정해야 한다. Chromium 주소창에 chrome://flags 를 입력하면 아래와 같은 창이 뜬다.</span></p>
<p><img class="alignnone size-full wp-image-191" src="http://bearpot.net/blog/wp-content/uploads/2017/08/Chromium-1.png" alt="" width="840" height="358" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/Chromium-1.png 840w, http://bearpot.net/blog/wp-content/uploads/2017/08/Chromium-1-300x128.png 300w, http://bearpot.net/blog/wp-content/uploads/2017/08/Chromium-1-768x327.png 768w" sizes="(max-width: 840px) 100vw, 840px" /></p>
<p><span style="font-size: 10pt;">실험실 기능에서 WebVR 및 Gamepad Extensions 를 사용하도록 체크하고 지금 다시 시작을 누르면, 정상적으로 WebVR API를 테스트해볼 수 있다. 간혹 WebVR API와 상관없이, WebGL 이 작동하지 않아 WebVR이 동작하지 않는 경우가 있는데, 주소창에 chrome://gpu 를 입력하고, Graphics feature 의 상태를 확인하여, 실험실 기능에서 WebGL 및 hardware accel 관련 기능을 사용하도록 한다.</span></p>
<p>4. WebVR Android Debugging</p>
<p><span style="font-size: 10pt;">크로미움으로 PC 환경에서 확인할 수 있지만, Android 를 베이스로 개발한다면, Chrome for Android(안드로이드에 기본적으로 깔려있는 크롬, 바로 그 것이다.) 를 사용해야 한다. 하지만 안드로이드에서 확인하는 것은 WebVR 웹주소 입력하는 점이나 디버깅 등 귀찮고 곤란한 점이 있다. 이 때 사용할 수 있는 것이 PC의 크롬 개발자 도구이다.</span></p>
<p><span style="font-size: 10pt;">크롬 개발자 도구에는 Remote devices 에 대해서도 기능을 지원하고 있다. (PC Chrome[F12] &gt; More tools &gt; Remote devices)</span></p>
<p><img class="alignnone size-full wp-image-189" src="http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움.png" alt="" width="554" height="293" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움.png 554w, http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움-300x159.png 300w" sizes="(max-width: 554px) 100vw, 554px" /></p>
<p><span style="font-size: 10pt;">USB나 wifi debugging 으로 연결하고 확인하면 아래와 같이 기기가 표시되고, New tab에 원하는 주소를 입력하면 안드로이드에서 자동 실행된다. Inspect 버튼을 누르면, PC 환경과 같이 디버깅에 사용할 수 있다. 이 때 주의할 점은 USB 허브 등을 사용하지 않고, 직접 PC와 연결해야 한다는 점이다. PC USB 단자에 직접 꽂아쓰도록 하자.</span></p>
<p><img class="alignnone size-full wp-image-194" src="http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움2.png" alt="" width="709" height="249" srcset="http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움2.png 709w, http://bearpot.net/blog/wp-content/uploads/2017/08/크로미움2-300x105.png 300w" sizes="(max-width: 709px) 100vw, 709px" /></p>
<p>5. 마무리</p>
<p><span style="font-size: 10pt;">WebVR API 설명에 대해서는 <a href="https://developer.mozilla.org/en-US/docs/Web/API">모질라</a>에 잘 설명되어 있다. 하지만 현재 진행 중이기 때문에, 쓰고 있던 API가 어느 순간, obsolete 처리될 수도 있다. Hardware agnostic 하다고 주장하지만, 지원 브라우저도 한정적이고, 사용가능한 VR 디바이스는 오큘러스, 삼성 기어VR, HTC Vive 및 안드로이드 디바이스 정도다. 크로미움 소스에서 확인한 바로는 OSVR 관련 내용을 porting 되어 있는데, OSVR Headset은 어느 정도 합(?)을 맞춰주면 작동할 수 있을 것같다. Three.js 는 기존 WebGL 에 비해 매우 간결하게 랜더링할 수 있었다. 또 한 A-frame 은 놀라울 정도로 쉽고, 직관적이라 빠르게 개발이 가능했다. WebVR 에 대해 더 많은 관심이 있다면 A Frame 을 알아보고 튜토리얼을 진행한다면, VR 웹앱을 금방 만들 수 있을 것이다. 사실 기존에 알고 싶었던 VR 헤드셋의 센서 패쓰 및 데이터 패킷 정의 부분에 대해서는 자료를 찾을 수 없었다. WebVR API 나 polyfill 의 소스에 정의되어 있지 않은 것으로 보아, Chromium 쪽일 것이라 확신하고, 소스를 둘러보았는데 당시에는 찾지 못 했고 다만 담당 개발자 Branden Jones 의 트윗이나 각 VR 해드셋의 센서 사용 방식으로 추측해보건데 브라우저에 센서 데이터를 처리하는 부분은 헤드셋별로 포함되어야 할 것이고, 직접 브라우저 소스 영역을 개발해야 하기 때문에 사용하기엔 시기상조라고 결론지었다.</span></p>
<p><span style="font-size: 10pt;">하지만 유니티는 기존에 &#8216;미리 보기&#8217;로 있던 WebGL, asm.js를 사용한 출력 기능인 WebGL exporter 를 공식 지원하기로 발표했다. (<a href="https://blogs.unity3d.com/kr/2015/12/08/unity-5-3-all-new-features-and-more-platforms/">Unity3d blog</a>) 언리얼은 Unreal Engine 4.7에서 HTML5 변환 기능을 탑재하면서 손쉽게 웹브라우저를 통해 컨텐츠를 제공할 수 있는 기능을 포함시켰다. (<a href="https://www.unrealengine.com/ko/blog/unreal-engine-47-released">GDC 2015, Unreal Engine 4.7 Released!</a>) 구글은 모질라와 구글 크롬팀의 Branden Jones 의 공동 작업으로, WebVR-polyfill 및 webVR-ui  를 개발 중이다. 오큘러스 또한 WebVR 전용 웹브라우저 &#8216;Carmel&#8217;을 발표하였고, 컨텐츠 개발 플랫폼 React VR 을 발표하였다. (<a href="https://developer.oculus.com/blog/introducing-the-react-vr-pre-release/">Introducing the React VR Pre-Release</a>) 네이티브 앱이 지고, 웹앱이 떠오르듯, VR앱 및 플랫폼 또한 Web based 로 발전하는 것은 VR의 고질적인 기술적 한계를 제외하면 시간 문제일 듯싶다. </span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/08/02/webvr-%ea%b0%9c%ec%9a%94/" title="1:01 오전" rel="bookmark"><time class="entry-date" datetime="2017-08-02T01:01:09+00:00">2017년 8월 2일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/android-debugging/" rel="tag">android debugging</a>, <a href="http://bearpot.net/blog/tag/chromium/" rel="tag">chromium</a>, <a href="http://bearpot.net/blog/tag/webvr/" rel="tag">webvr</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/08/02/webvr-%ea%b0%9c%ec%9a%94/#comments">댓글 한 개</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<article id="post-182" class="no-thumbnail post-182 post type-post status-publish format-standard hentry category-blog category-nodejsmongodb tag-crud tag-mongodb tag-mongodbcrud">
	<header class="entry-header">
				<h1 class="entry-title"><a href="http://bearpot.net/blog/2017/07/31/mongodb-crud/" rel="bookmark">mongodb CRUD</a></h1>	</header><!-- .entry-header -->

		<div class="entry-content">
		<p><span style="font-size: 14pt;">1. Create</span></p>
<p><span style="font-size: 10pt;">mongodb 의 데이터 삽입을 위해 .insert 연산을 사용한다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.insert({name: 'dg.jung', website: 'bearpot.net'})
WriteResult({ "nInserted" : 1 })
&gt; db.newCollection.find().pretty()
{
        "_id" : ObjectId("597eec3a89a6a3757fb5f20c"),
        "name" : "dg.jung",
        "website" : "bearpot.net"
}</pre>
<p><span style="font-size: 10pt;">데이터 삽입 후 find()를 통해 반환해보면, _id 값이라는 게 생겼다. _id 필드는 mongodb가 모든 도큐먼트를 고유하게 식별하는 데 사용하는 일종의 p.k(primary key) 라고 생각하면 된다.</span></p>
<p>2. Read</p>
<p><span style="font-size: 10pt;">read 는 find() 로 모두 해결이 가능하다. 아래와 같이 원하는 정보를 가져오기 위해 원하는 만큼 특정한 객체를 인자로 넘겨주면 된다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.find({name:'dg.jung'})
{ "_id" : ObjectId("597eec3a89a6a3757fb5f20c"), "name" : "dg.jung", "website" : "bearpot.net" }
&gt; db.newCollection.find({website:'bearpot.net'})
{ "_id" : ObjectId("597eec3a89a6a3757fb5f20c"), "name" : "dg.jung", "website" : "bearpot.net" }</pre>
<p><span style="font-size: 10pt;">find()로 반환되는 결과 중 특정 필드만 보고 싶다면 아래처럼 두 번째 인자를 이용한다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.find({website:'bearpot.net'}, {name:true})
{ "_id" : ObjectId("597eec3a89a6a3757fb5f20c"), "name" : "dg.jung" }</pre>
<p><span style="font-size: 10pt;">여러 개의 도큐먼트를 반환하는 경우에, 첫 번째 한 가지만 반환받고자 한다면, find() 대신 findOne()을 사용한다.</span></p>
<p>3. Update</p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.update({name:'dg.jung'},{website:'bearpotforever.com'})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
&gt; db.newCollection.find()
{ "_id" : ObjectId("597eec3a89a6a3757fb5f20c"), "website" : "bearpotforever.com" }
&gt; db.newCollection.find({name:'dg.jung'})
&gt;</pre>
<p><span style="font-size: 10pt;">update할 때는 첫 번째 인자에 검색 쿼리를 넣어준다. 그리고 두 번째 인자에 수정할 데이터를 넣는다. 여기서 신기한 점은 첫번째 쿼리에서 name 이 dg.jung 인 도큐먼트의 웹사이트를 수정하라는 쿼리를 보냈으나, 확인해보면 name이 dg.jung은 사라지고, 수정 내용은 insert 되어있다. 이는 mongodb(NoSQL) 의 특성상 도큐먼트 필드의 개수는 유한하므로, update와 동시에 새로운 도큐먼트로 교체됐기 때문이다. 이를 해결하기 위해 $set 연산자를 사용한다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.update({name:'dg.jung'}, { $set:{website:'dgjung.it.com'} }) 
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
&gt; db.newCollection.find()
{ "_id" : ObjectId("597eec3a89a6a3757fb5f20c"), "name" : "dg.jung", "website" : "dgjung.it.com" }</pre>
<p><span style="font-size: 10pt;">update를 하려고 하는데, 검색 조건에 맞는 것이 있을 수도 있고, 없을 수도 있다. 맞는 게 있다면 update 되지만, 없다면 되지 않을 것이다. 이 때 검색 조건에 맞는 도큐먼트가 없어도 검색 조건을 기반으로 하여 update 하는 방법이 있다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newCollection.update({name : 'donggoo Jung'}, {name:'donggoo Jung',website:'donggoogle.com'}, {upsert: true})
WriteResult({
        "nMatched" : 0,
        "nUpserted" : 1,
        "nModified" : 0,
        "_id" : ObjectId("597ef3293f9830e267ec5b29")
})
&gt; db.newCollection.find({name:'donggoo Jung'})
{ "_id" : ObjectId("597ef3293f9830e267ec5b29"), "name" : "donggoo Jung", "website" : "donggoogle.com" }</pre>
<p><span style="font-size: 10pt;">세번째 인자에 {upsert: true} 를 주어, matched 는 0 지만, 1 upsert 가 수행되었다.</span></p>
<p><span style="font-size: 10pt;">※upsert &#8211; To insert rows into a database table if they do not already exist, or update them if they do.</span></p>
<p>4. Delete</p>
<p><span style="font-size: 10pt;">delete의 경우, find와 거의 동일하게 동작한다. 다만 결과를 반환하는 find에 비해, delete는 일치하는 데이터를 삭제한다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true">&gt; db.newcollection.remove({name:'donggoo Jung'})
WriteResult({ "nRemoved" : 0 })
&gt; db.newcollection.find({name:'donggoo Jung'})</pre>
<p><span style="font-size: 10pt;">모든 데이터를 삭제하고자 하면, drop을 사용해 컬렉션에 있는 모든 도큐먼트를 비운다.</span></p>
<pre class="nums:false lang:default highlight:0 decode:true ">db.newCollection.drop()</pre>
<p>5. 마무리</p>
<p><span style="font-size: 10pt;">NoSQL 에서의 CRUD에 대해 살펴보았다. 추가적인 mongodb 학습이 필요하다면 mongodb 공식 홈페이지가 가장 좋은 선택이다. mongodb에서는 7-8주간의 mongodb tutorial를 제공하고 있다. mongodb 전문가가 되고 싶다면 꾹 참고 완독해보는 것도 좋을 것이다. (<a href="https://university.mongodb.com/">https://university.mongodb.com/</a>)</span></p>
			</div><!-- .entry-content -->
	
	<footer class="entry-meta">
					<span class="post-date"><a href="http://bearpot.net/blog/2017/07/31/mongodb-crud/" title="6:19 오후" rel="bookmark"><time class="entry-date" datetime="2017-07-31T18:19:33+00:00">2017년 7월 31일</time></a></span><span class="byline"><span class="author vcard"><a class="url fn n" href="http://bearpot.net/blog/author/dg-jung/" title="DG JUNG 의 모든 글 보기" rel="author">DG JUNG</a></span></span>						<span class="tags-links">
				<a href="http://bearpot.net/blog/tag/crud/" rel="tag">CRUD</a>, <a href="http://bearpot.net/blog/tag/mongodb/" rel="tag">mongodb</a>, <a href="http://bearpot.net/blog/tag/mongodbcrud/" rel="tag">mongodbCRUD</a>			</span>
					
				<span class="comments-link"><a href="http://bearpot.net/blog/2017/07/31/mongodb-crud/#comments">댓글 한 개</a></span>
		
			</footer><!-- .entry-meta -->
</article><!-- #post-## -->

			
				<nav role="navigation" id="nav-below" class="navigation-paging">
		<h1 class="screen-reader-text">글 네비게이션</h1>

	
				<div class="nav-previous"><a href="http://bearpot.net/blog/page/2/" ><span class="meta-nav">&larr;</span>이전 글</a></div>
		
		
	
	</nav><!-- #nav-below -->
	
		
		</div><!-- #content -->
	</div><!-- #primary -->

	<div id="secondary" class="widget-area" role="complementary">
							<div class="sidebar-1">
						<aside id="recent-posts-8" class="widget widget_recent_entries">		<h1 class="widget-title">최근 글</h1>		<ul>
					<li>
				<a href="http://bearpot.net/blog/2017/08/07/cpu-usage-cgroup-cpusets-viewer2/">CPU Usage &#038; CGROUP CPUSETS Viewer(2)</a>
						</li>
					<li>
				<a href="http://bearpot.net/blog/2017/08/06/2-kernel-build-modules/">2. Kernel Build</a>
						</li>
					<li>
				<a href="http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/">imgOverflow.io(5)-Mongoose(2)</a>
						</li>
					<li>
				<a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/">imgOverflow.io(4)-Mongoose(1)</a>
						</li>
					<li>
				<a href="http://bearpot.net/blog/2017/08/05/imgoverflow-io3-handlebar-helper/">imgOverflow.io(3)-handlebar helper</a>
						</li>
				</ul>
		</aside>					</div>
							<div class="sidebar-2">
				<aside id="recent-comments-8" class="widget widget_recent_comments"><h1 class="widget-title">최근 댓글</h1><ul id="recentcomments"><li class="recentcomments"><span class="comment-author-link">특곰탕</span> (<a href="http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/#comment-43">imgOverflow.io(5)-Mongoose(2)</a>)</li><li class="recentcomments"><span class="comment-author-link"><a href='http://bearpot.net/blog/2017/08/06/imgoverflow-io5-mongoose2/' rel='external nofollow' class='url'>imgOverflow.io(5)-Mongoose(2) | bearpot</a></span> (<a href="http://bearpot.net/blog/2017/08/05/imgploadr-io4-mongoose1/#comment-42">imgOverflow.io(4)-Mongoose(1)</a>)</li><li class="recentcomments"><span class="comment-author-link">Rodeo</span> (<a href="http://bearpot.net/blog/2017/08/03/imgoverflow-io2-multer/#comment-41">imgOverflow.io(2)-multer</a>)</li><li class="recentcomments"><span class="comment-author-link">닥터드레아드레</span> (<a href="http://bearpot.net/blog/2017/07/31/nodejs-mongodb-%ec%97%b0%eb%8f%99/#comment-39">nodejs &#038; mongodb 연동</a>)</li><li class="recentcomments"><span class="comment-author-link">쭈꾸미집</span> (<a href="http://bearpot.net/blog/2017/08/02/webvr-%ea%b0%9c%ec%9a%94/#comment-38">WebVR 개요</a>)</li></ul></aside>			</div>
							<div class="sidebar-3">
				<aside id="text-9" class="widget widget_text"><h1 class="widget-title">bearpot</h1>			<div class="textwidget"><p><a href="http://bearpot.net"><strong><em>bearpot.net</em></strong></a></p>
</div>
		</aside>			</div>
			</div><!-- #secondary -->

	</div><!-- #main -->
	<footer id="colophon" class="site-footer" role="contentinfo">
				<div class="site-info">
						<a href="http://wordpress.org/" title="의미론적 개인 출판 플랫폼" rel="generator">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			테마: Syntax(<a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a> 제작).		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='http://bearpot.net/blog/wp-content/themes/syntax/js/siteheader.js?ver=20120206'></script>
<script type='text/javascript' src='http://bearpot.net/blog/wp-content/themes/syntax/js/skip-link-focus-fix.js?ver=20130115'></script>
<script type='text/javascript' src='http://bearpot.net/blog/wp-includes/js/wp-embed.min.js?ver=4.8'></script>

</body>
</html>